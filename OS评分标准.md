满分：100分。

- Bootloader (10分)
    - 静态Bootloader（5分）
    - 动态地址Bootloader（3分）
    - 正确切换到S模式, 进入main（2分）
- 内存初始化（10分）
    - 物理页分配器的初始化（5分）
    - 物理页分配器的分配和释放（5分）
- 内存管理（20分）
    - 页表的创建（5分）
    - 页表的查找、分配、释放（5分）
    - 物理内存管理器（Buddy）（10分）
- IO（10分）
    - 从终端输入字符（5分）
    - 从终端输出字符（5分）
- 进程加载（5分）
    - ELF parser可以采用已有的实现方式
    - 加载指定的若干进程（给定ELF文件）（5分）
- 调度（10分）
    - 实现上下文切换（8分）
    - 实现简单的调度策略（2分）
- 中断（20分）
    - 实现中断处理（5分）
    - 实现Syscall（15分），至少需要包含以下几个，如果用户态有需求可以实现更多。
        - Sys_fork
        - Sys_exit
        - Sys_exec
    - 中断的实现方式请参考XV6 Book Chapter 4.
- 用户态（10分）
    - 实现到用户态的切换（5分）
    - 实现简单的用户态应用（5分）
        - bash
        - echo（简单版即可）
- 关机（5分）
    - 实现关机（5分）
- 更多Bonus：
    - 实现自旋锁（5分）


Code Review：40分

将最终成绩和100分取min。多的部分考虑溢出到其他部分。

测试方式：在实现进程加载后，嵌入elf file。内核必须实现以下函数：

```
void putchar(char c);
char getchar(void);
void putint(int value);
int getint();
void yield(); // 如果你实现了进程调度
```

这些函数应当可以被elf file使用。

大作业要求撰写文档：证明你的每一个功能被良好地实现了。
- 请按照评分点撰写你的报告。
- 可以：放代码截图/片段，文字阐述 +（可选）运行结果截图。需要证明该功能被你完整实现了。
- 格式：markdown即可。想写latex也可以。
- 在能说明白的前提下字数**越少越好**。
    - 卷字数对你的时间和助教的时间都是浪费 :-)
